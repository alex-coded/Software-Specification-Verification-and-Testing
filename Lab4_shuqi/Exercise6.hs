-- Study: MSc Software Engineering.
-- This file is intended to test the functionality of functions "symClos" and "trClos" from Exercise3.hs and Exercise5.hs.
-- Time spent: 120 minutes

module Exercise6 where

import Exercise3(symClos)
import Exercise5(trClos)
import SetOrd
import Test.QuickCheck

type Rel a = [(a,a)]

-- This function checks whether the following property of symmetry
-- Symmetricity: for every tuple (x,y) look if there is (y,x)
isSymmetric :: (Eq a, Ord a) => Rel a -> Bool
isSymmetric r = let symmetric = symClos r
                in and [elem (y, x) symmetric | (x, y) <- symmetric]

-- This function checks whether all closures in the original relation is in the symmetric version.
subsetSymmetric :: (Eq a, Ord a) => Rel a -> Bool
subsetSymmetric r = let symmetric = symClos r
                    in and [elem c symmetric | c <- r]

-- Transtivity: for every closure (x,y) where (y,z) is a closure, (x,z) should also be a closure.
isTransitive :: (Eq a, Ord a) => Rel a -> Bool
isTransitive r = let transitive = trClos r
                 in and [elem (x, t) transitive| (x, y) <- transitive, (z, t) <- transitive, y == z]

-- This function checks whether all closures in the original relation is in the transitive version.
subsetTransitive :: (Eq a, Ord a) => Rel a -> Bool
subsetTransitive r = let transitive = trClos r
                    in and [elem c transitive | c <- r]

main :: IO ()
main = do
    quickCheck $ forAll (arbitrary :: Gen [(Int, Int)])$ isSymmetric
    quickCheck $ forAll (arbitrary :: Gen [(Int, Int)])$ subsetSymmetric
    quickCheck $ forAll (arbitrary :: Gen [(Int, Int)])$ isTransitive
    quickCheck $ forAll (arbitrary :: Gen [(Int, Int)])$ subsetTransitive

{-
--------- LIBRARIES ---------

In this program, the following libraries are used:

- Exercise3: Where "symClos" function is implemented.
- Exercise5: Where "trClos" function is implemented.
- SetOrd: Type defination of Rel is defined in this module.
- Test.QuickCheck: To automatically test "symClos" and "trClos" functions.

--------- CODE DESCRIPTION (PURPOSE, FEATURES, ARCHITECTURE) ---------

This program is intended to test the functionality of functions "symClos" and "trClos" from Exercise3.hs and Exercise5.hs.
Four tests are caried out:

1. isSymmetric: This function checks for every tuple (x,y) in the result generated by symClos function whether there is also (y,x) in the result.
                This function returns True if the above symmetric property is valid and False otherwise
2. subsetSymmetric: This function checks whether all elements in the input relation are also included in the symmetric closures.
3. isTransitive: This function checks for every tuple (x,y) in the result generated by trClos function for every closure (x,y) where (y,z) is a closure, (x,z) should also be a closure
4. subsetTransitive: This function checks whether all elements in the input relation are also included in the transitive closures.

--------- TESTING APPROACH ---------

To test the implementation of the validateLTS function, we automatically tested a number of different
properties. All properties are of type Bool, since they all use generators to generate relevant test
cases. The following properties were checked:

1. An IOLTS with an empty state list Q is always invalid.
2. An IOLTS with a start state q0 that is not in the state list Q, is always invalid.
3. An IOLTS that contains a state in a transition that is not in the state list Q, is always invalid.
4. An IOLTS that contains a label in a transition that is not in the label lists (Li + Lu + tau), is always invalid.

Each property needs its own generator to generate relevant testcases, see Exercise2.hs for the
explanation of all the generators.

As expected, all tests passed, giving the following output:
+++ OK, passed 100 tests.
+++ OK, passed 100 tests.
+++ OK, passed 100 tests.
+++ OK, passed 100 tests.

This means that the implementation of the functions "symClos" and "trClos" is most likely correct.

-}
